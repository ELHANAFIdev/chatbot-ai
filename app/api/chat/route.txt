import { NextResponse } from "next/server"
import { openai } from "@ai-sdk/openai"
import { generateText } from "ai"
import { query } from "@/lib/db"

export const maxDuration = 30


// Dictionnaire de synonymes pour les recherches d'animaux
const animalSynonyms = {
  chien: ["chien", "chiot", "dog", "puppy", "canin", "toutou", "griffon"], // Ajout d'une race pour l'exemple
  chat: ["chat", "chaton", "cat", "kitten", "fÃ©lin", "minou", "siamois"],
  animal: ["animal", "pet", "bÃªte", "crÃ©ature"],
}

// Enhanced language detection with better Arabic support
function detectLanguage(text: string): "ar" | "fr" | "en" {
  const lowerText = text.toLowerCase().trim()
  console.log("ğŸ—£ï¸ Detecting language for:", lowerText)

  // Arabic detection (highest priority) - Enhanced
  if (/[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(text)) {
    console.log("âœ… Detected: Arabic (Unicode)")
    return "ar"
  }

  // Arabic keywords detection
  const arabicKeywords = [
    "ÙÙ‚Ø¯Øª",
    "ÙÙ‚Ø¯",
    "Ø¶Ø§Ø¹",
    "Ø¶Ø§Ø¦Ø¹",
    "Ù…ÙÙ‚ÙˆØ¯",
    "Ù…ÙÙ‚ÙˆØ¯Ø©",
    "Ø£Ø¨Ø­Ø«",
    "Ø§Ø¨Ø­Ø«",
    "Ø£Ø±ÙŠØ¯",
    "Ø£Ø¬Ø¯",
    "ÙˆØ¬Ø¯Øª",
    "Ø¨Ø­Ø«",
    "Ù‡Ø§ØªÙ",
    "Ø¬ÙˆØ§Ù„",
    "Ù…ÙˆØ¨Ø§ÙŠÙ„",
    "ØªÙ„ÙÙˆÙ†",
    "Ù…Ø­ÙØ¸Ø©",
    "Ù…ÙØªØ§Ø­",
    "Ù…ÙØ§ØªÙŠØ­",
    "Ø­Ù‚ÙŠØ¨Ø©",
    "Ø´Ù†Ø·Ø©",
    "Ø³Ø§Ø¹Ø©",
    "Ù†Ø¸Ø§Ø±Ø§Øª",
    "Ù†Ø¸Ø§Ø±Ø©",
    "Ø®Ø§ØªÙ…",
    "ÙƒÙ„Ø¨",
    "Ù‚Ø·",
    "Ù‚Ø·Ø©",
    "Ø­ÙŠÙˆØ§Ù†",
    "Ø¬ÙˆØ§Ø²",
    "Ø¨Ø·Ø§Ù‚Ø©",
    "ÙˆØ«ÙŠÙ‚Ø©",
    "Ø§Ù„Ø¯Ø§Ø± Ø§Ù„Ø¨ÙŠØ¶Ø§Ø¡",
    "Ø§Ù„Ø±Ø¨Ø§Ø·",
    "Ù…Ø±Ø§ÙƒØ´",
    "ÙØ§Ø³",
    "Ø·Ù†Ø¬Ø©",
    "Ø£ØºØ§Ø¯ÙŠØ±",
    "Ø£Ø³ÙˆØ¯",
    "Ø£Ø¨ÙŠØ¶",
    "Ø£Ø­Ù…Ø±",
    "Ø£Ø²Ø±Ù‚",
    "Ø£Ø®Ø¶Ø±",
    "Ø£ØµÙØ±",
    "Ø³Ø§Ù…Ø³ÙˆÙ†Øº",
    "Ø³Ø§Ù…Ø³ÙˆÙ†Ø¬",
    "Ø¢ÙŠÙÙˆÙ†",
    "ÙÙŠ",
    "Ù…Ù†",
    "Ø¥Ù„Ù‰",
    "Ø¹Ù†Ø¯",
  ]

  let arabicScore = 0
  for (const keyword of arabicKeywords) {
    if (text.includes(keyword)) {
      arabicScore += 2
    }
  }

  if (arabicScore > 0) {
    console.log("âœ… Detected: Arabic (keywords)")
    return "ar"
  }

  // Enhanced French detection
  const frenchIndicators = [
    "je",
    "j'ai",
    "tu",
    "il",
    "elle",
    "nous",
    "vous",
    "ils",
    "elles",
    "mon",
    "ma",
    "mes",
    "ton",
    "ta",
    "tes",
    "son",
    "sa",
    "ses",
    "le",
    "la",
    "les",
    "un",
    "une",
    "des",
    "du",
    "de",
    "dans",
    "Ã ",
    "avec",
    "pour",
    "sur",
    "par",
    "sans",
    "sous",
    "perdu",
    "perdue",
    "cherche",
    "trouve",
    "trouvÃ©",
    "tÃ©lÃ©phone",
    "portable",
    "sac",
    "clÃ©",
    "clÃ©s",
    "portefeuille",
    "lunettes",
    "chien",
    "chat",
    "oÃ¹",
    "quand",
    "comment",
    "pourquoi",
    "c'est",
    "qu'il",
    "qu'elle",
  ]

  // English indicators
  const englishIndicators = [
    "i",
    "you",
    "he",
    "she",
    "we",
    "they",
    "my",
    "your",
    "his",
    "her",
    "the",
    "a",
    "an",
    "in",
    "at",
    "on",
    "with",
    "for",
    "and",
    "or",
    "lost",
    "find",
    "search",
    "looking",
    "missing",
    "found",
    "phone",
    "bag",
    "key",
    "keys",
    "wallet",
    "glasses",
    "dog",
    "cat",
    "where",
    "when",
    "what",
    "how",
    "is",
    "was",
    "have",
    "do",
    "will",
    "can",
  ]

  let frenchScore = 0
  let englishScore = 0

  for (const indicator of frenchIndicators) {
    if (lowerText.includes(indicator)) {
      const weight = ["j'ai", "oÃ¹", "c'est", "tÃ©lÃ©phone", "perdu"].includes(indicator) ? 2 : 1
      frenchScore += weight
    }
  }

  for (const indicator of englishIndicators) {
    if (lowerText.includes(indicator)) {
      englishScore++
    }
  }

  console.log(`ğŸ“Š Language scores - French: ${frenchScore}, English: ${englishScore}`)

  if (frenchScore > englishScore) {
    console.log("âœ… Detected: French")
    return "fr"
  } else if (englishScore > frenchScore) {
    console.log("âœ… Detected: English")
    return "en"
  } else if (frenchScore === englishScore && frenchScore > 0) {
    console.log("âœ… Detected: French (preference)")
    return "fr"
  }

  console.log("âœ… Detected: French (default)")
  return "fr"
}

// Function to detect if user is asking about a specific item ID
function isAskingAboutItemId(text: string) {
  const patterns = [
    /\b(item|objet|id|number|numÃ©ro|#)\s*(\d+)\b/i,
    /\b(\d+)\s*(item|objet|id|number|numÃ©ro)\b/i,
    /^#?\s*(\d+)$/,
  ]

  for (const pattern of patterns) {
    const match = text.match(pattern)
    if (match) {
      const numberId = match.find((group) => /^\d+$/.test(group))
      if (numberId) {
        return Number.parseInt(numberId)
      }
    }
  }
  return null
}

// Enhanced translation dictionary - Arabic to French
const translationDictionary = {
  // Search actions - Actions de recherche
  ÙÙ‚Ø¯Øª: "perdu",
  ÙÙ‚Ø¯: "perdu",
  Ø¶Ø§Ø¹: "perdu",
  Ø¶Ø§Ø¦Ø¹: "perdu",
  Ù…ÙÙ‚ÙˆØ¯: "perdu",
  Ù…ÙÙ‚ÙˆØ¯Ø©: "perdu",
  Ø£Ø¨Ø­Ø«: "cherche",
  Ø§Ø¨Ø­Ø«: "cherche",
  Ø¨Ø­Ø«: "cherche",
  Ø£Ø±ÙŠØ¯: "cherche",
  Ø£Ø¬Ø¯: "trouve",
  ÙˆØ¬Ø¯Øª: "trouvÃ©",
  Ø§Ù„Ø¹Ø«ÙˆØ±: "trouve",
  Ø§Ù„Ø¨Ø­Ø«: "cherche",

  // Electronics - Ã‰lectronique
  Ù‡Ø§ØªÙ: "tÃ©lÃ©phone",
  Ø¬ÙˆØ§Ù„: "tÃ©lÃ©phone",
  Ù…ÙˆØ¨Ø§ÙŠÙ„: "tÃ©lÃ©phone",
  ØªÙ„ÙÙˆÙ†: "tÃ©lÃ©phone",
  Ø­Ø§Ø³ÙˆØ¨: "ordinateur",
  ÙƒÙ…Ø¨ÙŠÙˆØªØ±: "ordinateur",
  Ù„Ø§Ø¨ØªÙˆØ¨: "ordinateur",
  Ù„ÙˆØ­ÙŠ: "tablette",
  ØªØ§Ø¨Ù„Øª: "tablette",

  // Personal items - Objets personnels
  Ù…Ø­ÙØ¸Ø©: "portefeuille",
  Ù…ÙØªØ§Ø­: "clÃ©",
  Ù…ÙØ§ØªÙŠØ­: "clÃ©s",
  Ø­Ù‚ÙŠØ¨Ø©: "sac",
  Ø´Ù†Ø·Ø©: "sac",
  Ø³Ø§Ø¹Ø©: "montre",
  Ù†Ø¸Ø§Ø±Ø§Øª: "lunettes",
  Ù†Ø¸Ø§Ø±Ø©: "lunettes",
  Ø®Ø§ØªÙ…: "bague",

  // Animals - Animaux
  ÙƒÙ„Ø¨: "chien",
  Ù‚Ø·: "chat",
  Ù‚Ø·Ø©: "chat",
  Ø­ÙŠÙˆØ§Ù†: "animal",

  // Documents
  Ø¬ÙˆØ§Ø²: "passeport",
  "Ø¬ÙˆØ§Ø² Ø³ÙØ±": "passeport",
  Ø¨Ø·Ø§Ù‚Ø©: "carte",
  ÙˆØ«ÙŠÙ‚Ø©: "document",

  // Cities - Villes (Arabic to French)
  "Ø§Ù„Ø¯Ø§Ø± Ø§Ù„Ø¨ÙŠØ¶Ø§Ø¡": "casablanca",
  Ø§Ù„Ø¨ÙŠØ¶Ø§Ø¡: "casablanca",
  ÙƒØ§Ø²Ø§: "casablanca",
  Ø§Ù„Ø±Ø¨Ø§Ø·: "rabat",
  Ù…Ø±Ø§ÙƒØ´: "marrakech",
  ÙØ§Ø³: "fes",
  Ø·Ù†Ø¬Ø©: "tanger",
  Ø£ØºØ§Ø¯ÙŠØ±: "agadir",
  Ù…ÙƒÙ†Ø§Ø³: "meknes",
  ÙˆØ¬Ø¯Ø©: "oujda",
  Ø§Ù„Ù‚Ù†ÙŠØ·Ø±Ø©: "kenitra",
  ØªØ·ÙˆØ§Ù†: "tetouan",

  // Colors - Couleurs
  Ø£Ø³ÙˆØ¯: "noir",
  Ø£Ø¨ÙŠØ¶: "blanc",
  Ø£Ø­Ù…Ø±: "rouge",
  Ø£Ø²Ø±Ù‚: "bleu",
  Ø£Ø®Ø¶Ø±: "vert",
  Ø£ØµÙØ±: "jaune",

  // Brands - Marques
  Ø¢ÙŠÙÙˆÙ†: "iphone",
  Ø§ÙŠÙÙˆÙ†: "iphone",
  Ø³Ø§Ù…Ø³ÙˆÙ†Øº: "samsung",
  Ø³Ø§Ù…Ø³ÙˆÙ†Ø¬: "samsung",

  // Prepositions and common words
  ÙÙŠ: "Ã ",
  Ù…Ù†: "de",
  Ø¥Ù„Ù‰: "Ã ",
  Ø¹Ù†Ø¯: "chez",
  Ù…Ø¹: "avec",

  // Existing translations remain the same...
  phone: "tÃ©lÃ©phone",
  smartphone: "tÃ©lÃ©phone",
  mobile: "tÃ©lÃ©phone",
  laptop: "ordinateur",
  computer: "ordinateur",
  pc: "ordinateur",
  tablet: "tablette",
  wallet: "portefeuille",
  key: "clÃ©",
  keys: "clÃ©s",
  bag: "sac",
  backpack: "sac",
  watch: "montre",
  glasses: "lunettes",
  ring: "bague",
  dog: "chien",
  cat: "chat",
  pet: "animal",
  passport: "passeport",
  card: "carte",
  document: "document",
  umbrella: "parapluie",
  bicycle: "vÃ©lo",
  bike: "vÃ©lo",
  book: "livre",
  money: "argent",
  casa: "casablanca",
  marrakesh: "marrakech",
  fez: "fes",
  tangier: "tanger",
  black: "noir",
  white: "blanc",
  red: "rouge",
  blue: "bleu",
  green: "vert",
  yellow: "jaune",
  iphone: "iphone",
  lost: "perdu",
  find: "trouve",
  search: "cherche",
  looking: "cherche",
  missing: "perdu",
  found: "trouvÃ©",
}

// Function to translate text to French (especially Arabic)
function translateToFrench(text: string): string {
  let translatedText = text.toLowerCase()

  console.log("ğŸ”„ Original text:", text)

  // Special handling for Arabic text
  const hasArabic = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(text)

  if (hasArabic) {
    console.log("ğŸ”„ Processing Arabic text")

    // Replace Arabic phrases first (longer phrases before single words)
    const arabicPhrases = ["Ø¬ÙˆØ§Ø² Ø³ÙØ±", "Ø§Ù„Ø¯Ø§Ø± Ø§Ù„Ø¨ÙŠØ¶Ø§Ø¡", "ÙÙ‚Ø¯Øª Ù‡Ø§ØªÙÙŠ", "Ø£Ø¨Ø­Ø« Ø¹Ù†", "Ø¶Ø§Ø¹ Ù…Ù†ÙŠ"]

    for (const phrase of arabicPhrases) {
      if (text.includes(phrase) && translationDictionary[phrase]) {
        translatedText = translatedText.replace(new RegExp(phrase, "g"), translationDictionary[phrase])
        console.log(`ğŸ”„ Translated phrase "${phrase}" â†’ "${translationDictionary[phrase]}"`)
      }
    }
  }

  // Replace each word/phrase with its French equivalent
  for (const [original, french] of Object.entries(translationDictionary)) {
    if (text.includes(original)) {
      const regex = new RegExp(original.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "gi")
      translatedText = translatedText.replace(regex, french)
      console.log(`ğŸ”„ Translated "${original}" â†’ "${french}"`)
    }
  }

  console.log("âœ… Final translated text:", translatedText)
  return translatedText
}

// Enhanced function to extract specific brands and models with precision
function extractPreciseSpecs(text: string) {
  const translatedText = translateToFrench(text)
  const lowerText = translatedText.toLowerCase()
  const originalLower = text.toLowerCase()

  console.log("ğŸ” Extracting precise specs from:", lowerText)

  // Color detection
  const colors = {
    noir: ["noir", "black", "Ø£Ø³ÙˆØ¯"],
    blanc: ["blanc", "white", "Ø£Ø¨ÙŠØ¶"],
    rouge: ["rouge", "red", "Ø£Ø­Ù…Ø±"],
    bleu: ["bleu", "blue", "Ø£Ø²Ø±Ù‚"],
    vert: ["vert", "green", "Ø£Ø®Ø¶Ø±"],
    jaune: ["jaune", "yellow", "Ø£ØµÙØ±"],
    rose: ["rose", "pink", "ÙˆØ±Ø¯ÙŠ"],
    gris: ["gris", "gray", "grey", "Ø±Ù…Ø§Ø¯ÙŠ"],
    marron: ["marron", "brown", "Ø¨Ù†ÙŠ"],
    violet: ["violet", "purple", "Ø¨Ù†ÙØ³Ø¬ÙŠ"],
  }

  let detectedColor = null
  for (const [frenchColor, colorKeywords] of Object.entries(colors)) {
    for (const keyword of colorKeywords) {
      if (lowerText.includes(keyword) || originalLower.includes(keyword)) {
        detectedColor = frenchColor
        console.log(`ğŸ¨ Found color: ${frenchColor} (${keyword})`)
        break
      }
    }
    if (detectedColor) break
  }

  // Enhanced brand detection with car brands
  const brandSpecs = {
    // Car brands
    renault: {
      brand: "renault",
      category: "clÃ©",
      keywords: ["renault"],
      strictBrands: ["renault"],
    },
    peugeot: {
      brand: "peugeot",
      category: "clÃ©",
      keywords: ["peugeot"],
      strictBrands: ["peugeot"],
    },
    citroen: {
      brand: "citroÃ«n",
      category: "clÃ©",
      keywords: ["citroÃ«n", "citroen"],
      strictBrands: ["citroÃ«n", "citroen"],
    },
    // Phone brands
    iphone: {
      brand: "apple",
      category: "tÃ©lÃ©phone",
      keywords: ["iphone", "Ø¢ÙŠÙÙˆÙ†", "Ø§ÙŠÙÙˆÙ†"],
      strictBrands: ["apple", "iphone"],
    },
    samsung: {
      brand: "samsung",
      category: "tÃ©lÃ©phone",
      keywords: ["samsung", "galaxy", "Ø³Ø§Ù…Ø³ÙˆÙ†Øº", "Ø³Ø§Ù…Ø³ÙˆÙ†Ø¬"],
      strictBrands: ["samsung"],
    },
    huawei: {
      brand: "huawei",
      category: "tÃ©lÃ©phone",
      keywords: ["huawei", "mate", "p30", "p40"],
      strictBrands: ["huawei"],
    },
    xiaomi: {
      brand: "xiaomi",
      category: "tÃ©lÃ©phone",
      keywords: ["xiaomi", "redmi", "mi"],
      strictBrands: ["xiaomi"],
    },
    nokia: {
      brand: "nokia",
      category: "tÃ©lÃ©phone",
      keywords: ["nokia"],
      strictBrands: ["nokia"],
    },
    sony: {
      brand: "sony",
      category: "tÃ©lÃ©phone",
      keywords: ["sony", "xperia"],
      strictBrands: ["sony"],
    },
    lg: {
      brand: "lg",
      category: "tÃ©lÃ©phone",
      keywords: ["lg"],
      strictBrands: ["lg"],
    },
    motorola: {
      brand: "motorola",
      category: "tÃ©lÃ©phone",
      keywords: ["motorola", "moto"],
      strictBrands: ["motorola"],
    },
    oneplus: {
      brand: "oneplus",
      category: "tÃ©lÃ©phone",
      keywords: ["oneplus", "one plus"],
      strictBrands: ["oneplus"],
    },
    oppo: {
      brand: "oppo",
      category: "tÃ©lÃ©phone",
      keywords: ["oppo"],
      strictBrands: ["oppo"],
    },
    vivo: {
      brand: "vivo",
      category: "tÃ©lÃ©phone",
      keywords: ["vivo"],
      strictBrands: ["vivo"],
    },
    realme: {
      brand: "realme",
      category: "tÃ©lÃ©phone",
      keywords: ["realme"],
      strictBrands: ["realme"],
    },
  }

  const foundSpecs = {
    brands: [],
    categories: [],
    color: detectedColor,
    isSpecific: false,
    strictBrands: [],
  }

  // Check for specific brand mentions
  for (const [key, spec] of Object.entries(brandSpecs)) {
    for (const keyword of spec.keywords) {
      if (lowerText.includes(keyword) || originalLower.includes(keyword)) {
        foundSpecs.brands.push(spec.brand)
        foundSpecs.categories.push(spec.category)
        foundSpecs.strictBrands.push(...spec.strictBrands)
        foundSpecs.isSpecific = true
        console.log(`ğŸ¯ Found specific brand: ${spec.brand} (${keyword})`)
        break
      }
    }
  }

  // If no specific brand found, look for general categories
  if (!foundSpecs.isSpecific) {
    const generalItems = [
      "clÃ©",
      "clÃ©s",
      "tÃ©lÃ©phone",
      "portable",
      "ordinateur",
      "tablette",
      "portefeuille",
      "sac",
      "montre",
      "lunettes",
      "bague",
      "chien",
      "chat",
      "animal",
      "passeport",
      "carte",
      "document",
      "chÃ¨que",
    ]

    for (const item of generalItems) {
      if (lowerText.includes(item) || originalLower.includes(item)) {
        foundSpecs.categories.push(item)
        console.log(`ğŸ“± Found general category: ${item}`)
      }
    }
  }

  // Remove duplicates
  foundSpecs.brands = [...new Set(foundSpecs.brands)]
  foundSpecs.categories = [...new Set(foundSpecs.categories)]
  foundSpecs.strictBrands = [...new Set(foundSpecs.strictBrands)]

  console.log("ğŸ¯ Final extracted specs:", foundSpecs)
  return foundSpecs
}

// Function to extractCities (now works with Arabic translation)
function extractCities(text: string) {
  // First translate the text to French (especially important for Arabic)
  const translatedText = translateToFrench(text)
  const lowerText = translatedText.toLowerCase()
  const originalLower = text.toLowerCase()

  // French cities
  const frenchCities = [
    "rabat",
    "casablanca",
    "marrakech",
    "fes",
    "tanger",
    "agadir",
    "meknes",
    "oujda",
    "kenitra",
    "tetouan",
  ]

  const foundCities = []

  // Search for French cities in translated AND original text
  for (const city of frenchCities) {
    if (lowerText.includes(city) || originalLower.includes(city)) {
      foundCities.push(city)
    }
  }

  console.log("ğŸ™ï¸ Extracted French cities:", foundCities)
  return [...new Set(foundCities)] // Remove duplicates
}

// Enhanced function to analyze conversation context
function analyzeConversationContext(messages: any[]) {
  let lastUserMessage = ""
  let lastAssistantMessage = ""
  const conversationSpecs = { brands: [], categories: [] }
  const conversationCities = []
  let userLanguage = "fr" // Default to French

  const recentMessages = messages.slice(-4)

  for (const message of recentMessages) {
    if (message.role === "user") {
      lastUserMessage = message.content
      userLanguage = detectLanguage(message.content)
      const specs = extractPreciseSpecs(message.content)
      const cities = extractCities(message.content)
      conversationSpecs.brands.push(...specs.brands)
      conversationSpecs.categories.push(...specs.categories)
      conversationCities.push(...cities)
    } else if (message.role === "assistant") {
      lastAssistantMessage = message.content
    }
  }

  // Check if this is a new search
  const currentSpecs = extractPreciseSpecs(lastUserMessage)
  const currentCities = extractCities(lastUserMessage)
  const currentLanguage = detectLanguage(lastUserMessage)

  const isNewSearch =
    (currentSpecs.brands.length > 0 || currentSpecs.categories.length > 0) &&
    (lastAssistantMessage.includes("matching items") ||
      lastAssistantMessage.includes("objets correspondants") ||
      lastAssistantMessage.includes("Ø¹Ù†Ø§ØµØ± Ù…Ø·Ø§Ø¨Ù‚Ø©") ||
      lastAssistantMessage.includes("No matches found") ||
      lastAssistantMessage.includes("Aucune correspondance") ||
      lastAssistantMessage.includes("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ±"))

  const isWaitingForDetails =
    lastAssistantMessage.includes("More details needed") ||
    lastAssistantMessage.includes("Plus de dÃ©tails") ||
    lastAssistantMessage.includes("ØªÙØ§ØµÙŠÙ„ Ø£ÙƒØ«Ø±") ||
    lastAssistantMessage.includes("need more information") ||
    lastAssistantMessage.includes("plus d'informations")

  return {
    lastUserMessage,
    lastAssistantMessage,
    conversationSpecs: isNewSearch
      ? currentSpecs
      : {
          brands: [...new Set(conversationSpecs.brands)],
          categories: [...new Set(conversationSpecs.categories)],
        },
    conversationCities: isNewSearch ? currentCities : [...new Set(conversationCities)],
    isWaitingForDetails,
    userLanguage: currentLanguage,
    isNewSearch,
  }
}

// Check if user is searching for items
// Check if user is searching for items (VERSION CORRIGÃ‰E ET PROACTIVE)
function isSearchingForItems(text: string, context: any = null) {
  console.log("ğŸ” Checking if searching for items:", text)

  // Translate first to detect keywords (especially important for Arabic)
  const translatedText = translateToFrench(text)
  console.log("ğŸ”„ Translated text for search detection:", translatedText)

  // Keywords that indicate a lost item search
  const lostKeywords = [
    // French
    "perdu", "perdus", "perdue", "perdues", "cherche", "recherche", "trouve", 
    "trouvÃ©", "retrouve", "retrouver",
    // English
    "lost", "missing", "search", "looking", "find", "found",
    // Arabic
    "ÙÙ‚Ø¯Øª", "ÙÙ‚Ø¯", "Ø¶Ø§Ø¹", "Ø¶Ø§Ø¦Ø¹", "Ù…ÙÙ‚ÙˆØ¯", "Ù…ÙÙ‚ÙˆØ¯Ø©", "Ø£Ø¨Ø­Ø«", "Ø§Ø¨Ø­Ø«", "Ø£Ø±ÙŠØ¯", 
    "Ø£Ø¬Ø¯", "ÙˆØ¬Ø¯Øª",
  ]

  // Check if text contains lost keywords
  const hasLostKeyword = lostKeywords.some((keyword) => {
    const textLower = text.toLowerCase()
    const translatedLower = translatedText.toLowerCase()
    return textLower.includes(keyword.toLowerCase()) || translatedLower.includes(keyword.toLowerCase())
  })

  // Check current message for specs and city
  const specs = extractPreciseSpecs(text)
  const hasSpecs = specs.brands.length > 0 || specs.categories.length > 0
  const hasCity = extractCities(text).length > 0

  console.log("ğŸ” Has lost keyword:", hasLostKeyword)
  console.log("ğŸ™ï¸ Has city:", hasCity)
  console.log("ğŸ“± Has specs:", hasSpecs, specs)

  // --- MODIFICATION PRINCIPALE ICI ---
  // Si l'utilisateur dÃ©crit un objet (hasSpecs = true), c'est une intention de recherche.
  // Les autres conditions (contexte, mot-clÃ©, ville) ne sont plus obligatoires pour le dÃ©clenchement.
  const isSearch = hasSpecs;

  // Si le contexte indique une attente, on confirme que c'est une recherche
  if (context?.isWaitingForDetails && hasSpecs) {
    console.log("âœ… Search confirmed by context (waiting for details)")
    return true
  }

  console.log("âœ… Final search decision (proactive logic):", isSearch)
  return isSearch
}

// Get item by ID
async function getItemById(itemId: number) {
  try {
    if (!process.env.DB_HOST) {
      throw new Error("Database not configured")
    }

    const sql = `
      SELECT 
        f.id,
        f.discription as description,
        f.ville as city_id,
        f.cat_ref as category_ref,
        f.marque,
        f.modele,
        f.color,
        f.type,
        f.etat,
        f.postdate,
        c.cname as category_name,
        v.ville as city
      FROM fthings f
      LEFT JOIN catagoery c ON f.cat_ref = c.cid
      LEFT JOIN ville v ON f.ville = v.id
      WHERE f.id = ?
      LIMIT 1
    `

    const results = await query(sql, [itemId])
    const resultArray = Array.isArray(results) ? results : []
    return resultArray.length > 0 ? resultArray[0] : null
  } catch (error) {
    console.error("Database error:", error)
    throw error
  }
}

// Extract search terms with context and precision
function extractSearchTerms(text: string, context: any = null) {
  let city = extractCities(text)[0] || null
  let specs = extractPreciseSpecs(text)

  // Only use context if it's not a new search AND we're missing info
  if (!context?.isNewSearch) {
    if (!city && context?.conversationCities.length > 0) {
      city = context.conversationCities[0]
    }

    if (
      specs.brands.length === 0 &&
      specs.categories.length === 0 &&
      (context?.conversationSpecs.brands.length > 0 || context?.conversationSpecs.categories.length > 0)
    ) {
      specs = context.conversationSpecs
    }
  }

  return {
    originalText: text,
    brands: specs.brands,
    categories: specs.categories,
    isSpecific: specs.isSpecific,
    strictBrands: specs.strictBrands || [], // Add strict brands
    city: city, // City is now optional
  }
}

// Generate multilingual responses - Updated to not require city
function generateResponse(type: string, data: any, language: string) {
  const responses = {
    missingDetails: {
      ar: `ğŸ“ **ØªÙØ§ØµÙŠÙ„ Ø£ÙƒØ«Ø± Ù…Ø·Ù„ÙˆØ¨Ø©!**

Ø£Ø­ØªØ§Ø¬ Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ù…ÙÙ‚ÙˆØ¯:

â€¢ **Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ø¹Ù†ØµØ±ØŸ** (Ù‡Ø§ØªÙØŒ Ù…Ø­ÙØ¸Ø©ØŒ Ù…ÙØ§ØªÙŠØ­)
â€¢ **Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©ØŸ** (Ø¢ÙŠÙÙˆÙ†ØŒ Ø³Ø§Ù…Ø³ÙˆÙ†ØºØŒ Ù‡ÙˆØ§ÙˆÙŠ)
â€¢ **Ø§Ù„Ù„ÙˆÙ†ØŸ** (Ø£Ø³ÙˆØ¯ØŒ Ø£Ø¨ÙŠØ¶ØŒ Ø£Ø­Ù…Ø±)
â€¢ **Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©ØŸ** (Ø§Ø®ØªÙŠØ§Ø±ÙŠ - ÙŠØ³Ø§Ø¹Ø¯ ÙÙŠ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù†ØªØ§Ø¦Ø¬)

**Ù…Ø«Ø§Ù„:** "ÙÙ‚Ø¯Øª Ø¢ÙŠÙÙˆÙ† Ø£Ø³ÙˆØ¯" Ø£Ùˆ "Ø£Ø¨Ø­Ø« Ø¹Ù† Ø³Ø§Ù…Ø³ÙˆÙ†Øº"

ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„ØªÙØ§ØµÙŠÙ„! ğŸ”`,

      fr: `ğŸ“ **Plus de dÃ©tails nÃ©cessaires !**

J'ai besoin de plus d'informations sur l'objet perdu :

â€¢ **Quel objet ?** (tÃ©lÃ©phone, portefeuille, clÃ©s)
â€¢ **Marque spÃ©cifique ?** (iPhone, Samsung, Huawei)
â€¢ **Couleur ?** (noir, blanc, rouge)
â€¢ **Ville ?** (optionnel - aide Ã  amÃ©liorer les rÃ©sultats)

**Exemple :** "J'ai perdu mon iPhone noir" ou "Je cherche un Samsung"

Veuillez fournir plus de dÃ©tails ! ğŸ”`,

      en: `ğŸ“ **More details needed!**

I need more information about the lost item:

â€¢ **What item?** (phone, wallet, keys)
â€¢ **Specific brand?** (iPhone, Samsung, Huawei)
â€¢ **Color?** (black, white, red)
â€¢ **City?** (optional - helps improve results)

**Example:** "I lost my black iPhone" or "Looking for Samsung"

Please provide more details! ğŸ”`,
    },
    searchResults: {
      ar: `ğŸ¯ **ÙˆØ¬Ø¯Øª ${data.count} Ø¹Ù†Ø§ØµØ± Ù…Ø·Ø§Ø¨Ù‚Ø©${data.city ? ` ÙÙŠ ${data.city}` : ""}!**

${data.isSpecific ? "ğŸ¯ **Ø¨Ø­Ø« Ø¯Ù‚ÙŠÙ‚** - Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ØªØ·Ø§Ø¨Ù‚ Ø§Ù„Ù…ÙˆØ§ØµÙØ§Øª Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©" : "ğŸ“‹ **Ø¨Ø­Ø« Ø¹Ø§Ù…** - Ù‚Ø¯ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¹Ù†Ø§ØµØ± Ù…Ø´Ø§Ø¨Ù‡Ø©"}

ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª Ø£Ø¯Ù†Ø§Ù‡ ÙˆØ§ØªØµÙ„ Ø¨Ø§Ù„Ø£Ø´Ø®Ø§Øµ Ø§Ù„Ø°ÙŠÙ† ÙˆØ¬Ø¯ÙˆØ§ Ø§Ù„Ø¹Ù†Ø§ØµØ±.`,

      fr: `ğŸ¯ **J'ai trouvÃ© ${data.count} objets correspondants${data.city ? ` Ã  ${data.city}` : ""} !**

${data.isSpecific ? "ğŸ¯ **Recherche prÃ©cise** - Les rÃ©sultats correspondent aux spÃ©cifications exactes" : "ğŸ“‹ **Recherche gÃ©nÃ©rale** - Peut contenir des objets similaires"}

Consultez les cartes ci-dessous et contactez les personnes qui ont trouvÃ© les objets.`,

      en: `ğŸ¯ **I found ${data.count} matching items${data.city ? ` in ${data.city}` : ""}!**

${data.isSpecific ? "ğŸ¯ **Precise search** - Results match exact specifications" : "ğŸ“‹ **General search** - May contain similar items"}

Check the cards below and contact the people who found the items.`,
    },
    noResults: {
      ar: `âŒ **Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø·Ø§Ø¨Ù‚Ø§Øª${data.city ? ` ÙÙŠ ${data.city}` : ""}**

${data.isSpecific ? "ğŸ¯ **Ø¨Ø­Ø« Ø¯Ù‚ÙŠÙ‚** - Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ù…Ø­Ø¯Ø¯" : "ğŸ“‹ **Ø¨Ø­Ø« Ø¹Ø§Ù…** - Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¹Ù†Ø§ØµØ± Ù…Ø´Ø§Ø¨Ù‡Ø©"}

Ù„Ø§ ØªÙ‚Ù„Ù‚! ÙŠÙ…ÙƒÙ†Ùƒ:

ğŸ†• **Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø¹Ù„Ø§Ù† Ø¬Ø¯ÙŠØ¯:**
[CRÃ‰ER_ANNONCE]

ğŸ” **Ø¬Ø±Ø¨ ÙƒÙ„Ù…Ø§Øª Ù…Ø®ØªÙ„ÙØ©** Ø£Ùˆ Ù…Ø¯Ù† Ø£Ø®Ø±Ù‰

ğŸ’¡ **Ù†ØµÙŠØ­Ø©:** ÙƒÙ† Ø£ÙƒØ«Ø± ØªØ­Ø¯ÙŠØ¯Ø§Ù‹ (Ù…Ø«Ø§Ù„: "Ø¢ÙŠÙÙˆÙ† 12 Ø£Ø³ÙˆØ¯")`,

      fr: `âŒ **Aucune correspondance trouvÃ©e${data.city ? ` Ã  ${data.city}` : ""}**

${data.isSpecific ? "ğŸ¯ **Recherche prÃ©cise** - Aucun objet correspondant aux spÃ©cifications exactes" : "ğŸ“‹ **Recherche gÃ©nÃ©rale** - Aucun objet similaire trouvÃ©"}

Ne vous inquiÃ©tez pas ! Vous pouvez :

ğŸ†• **CrÃ©er une nouvelle annonce :**
[CRÃ‰ER_ANNONCE]

ğŸ” **Essayez diffÃ©rents mots-clÃ©s** ou d'autres villes

ğŸ’¡ **Conseil :** Soyez plus spÃ©cifique (ex: "iPhone 12 noir")`,

      en: `âŒ **No matches found${data.city ? ` in ${data.city}` : ""}**

${data.isSpecific ? "ğŸ¯ **Precise search** - No items matching exact specifications" : "ğŸ“‹ **General search** - No similar items found"}

Don't worry! You can:

ğŸ†• **Create a new post:**
[CRÃ‰ER_ANNONCE]

ğŸ” **Try different keywords** or other cities

ğŸ’¡ **Tip:** Be more specific (e.g., "iPhone 12 black")`,
    },
  }

  return responses[type]?.[language] || responses[type]?.fr || "Erreur de gÃ©nÃ©ration de rÃ©ponse"
}

// Function to validate if a result matches the search criteria
function validateSearchResult(item: any, searchTerms: any): boolean {
  console.log("ğŸ” Validating result:", {
    itemId: item.id,
    itemBrand: item.marque,
    itemDescription: item.description,
    searchBrands: searchTerms.strictBrands,
    searchCategories: searchTerms.categories,
    isSpecific: searchTerms.isSpecific,
  })

  // Validation spÃ©ciale pour les animaux - Ãªtre plus permissif
  if (
    searchTerms.categories.includes("chien") ||
    searchTerms.categories.includes("chat") ||
    searchTerms.categories.includes("animal")
  ) {
    const itemDescription = (item.description || "").toLowerCase()
    const itemType = (item.type || "").toLowerCase()
    const originalSearch = searchTerms.originalText.toLowerCase()

    // Si l'utilisateur cherche un chien et que l'objet est un chien, c'est valide
    if (
      (originalSearch.includes("chien") || originalSearch.includes("dog")) &&
      (itemDescription.includes("chien") || itemDescription.includes("dog") || itemType.includes("chien"))
    ) {
      console.log(`âœ… Accepted: Dog match found`)
      return true
    }

    // Si l'utilisateur cherche un chat et que l'objet est un chat, c'est valide
    if (
      (originalSearch.includes("chat") || originalSearch.includes("cat")) &&
      (itemDescription.includes("chat") || itemDescription.includes("cat") || itemType.includes("chat"))
    ) {
      console.log(`âœ… Accepted: Cat match found`)
      return true
    }
  }

  // Si l'utilisateur cherche un contenu spÃ©cifique dans un sac
  if (searchTerms.categories.includes("sac") && searchTerms.originalText) {
    const itemDescription = (item.description || "").toLowerCase()
    const itemType = (item.type || "").toLowerCase()
    const originalSearch = searchTerms.originalText.toLowerCase()

    // DÃ©tecter si l'utilisateur cherche un contenu spÃ©cifique
    const specificContentKeywords = [
      "tapis de priÃ¨re",
      "prayer mat",
      "documents",
      "papiers",
      "vÃªtements",
      "clothes",
      "livres",
      "books",
      "mÃ©dicaments",
      "medicine",
      "bijoux",
      "jewelry",
      "argent",
      "money",
      "cartes",
      "cards",
    ]

    let searchedContent = null
    for (const keyword of specificContentKeywords) {
      if (originalSearch.includes(keyword)) {
        searchedContent = keyword
        break
      }
    }

    if (searchedContent) {
      console.log(`ğŸ¯ User is looking for specific content: ${searchedContent}`)

      // VÃ©rifier si l'objet contient le contenu recherchÃ©
      const hasSearchedContent = itemDescription.includes(searchedContent) || itemType.includes(searchedContent)

      if (!hasSearchedContent) {
        console.log(`âŒ Rejected: Bag doesn't contain searched content "${searchedContent}"`)
        return false
      }

      // Exclure les sacs avec du contenu non pertinent
      const irrelevantForPrayerMat = [
        "jouets",
        "toys",
        "enfants",
        "children",
        "aire de jeu",
        "playground",
        "jeux",
        "games",
      ]

      if (searchedContent.includes("tapis de priÃ¨re") || searchedContent.includes("prayer mat")) {
        const hasIrrelevantContent = irrelevantForPrayerMat.some(
          (keyword) => itemDescription.includes(keyword) || itemType.includes(keyword),
        )

        if (hasIrrelevantContent) {
          console.log(`âŒ Rejected: Bag contains irrelevant content for prayer mat search`)
          return false
        }
      }
    }
  }

  // Si c'est une recherche de marque spÃ©cifique, Ãªtre trÃ¨s strict
  if (searchTerms.isSpecific && searchTerms.strictBrands.length > 0) {
    const itemBrand = (item.marque || "").toLowerCase()
    const itemDescription = (item.description || "").toLowerCase()
    const itemModel = (item.modele || "").toLowerCase()
    const itemType = (item.type || "").toLowerCase()

    // VÃ©rifier si une des marques strictes correspond
    const hasStrictBrandMatch = searchTerms.strictBrands.some((strictBrand) => {
      const brandLower = strictBrand.toLowerCase()

      // Pour iPhone, accepter seulement Apple/iPhone
      if (strictBrand === "iphone" || strictBrand === "apple") {
        return (
          (itemBrand.includes("apple") ||
            itemBrand.includes("iphone") ||
            itemModel.includes("iphone") ||
            itemDescription.includes("iphone") ||
            itemType.includes("iphone")) &&
          !(
            itemBrand.includes("samsung") ||
            itemBrand.includes("huawei") ||
            itemBrand.includes("xiaomi") ||
            itemBrand.includes("nokia") ||
            itemBrand.includes("lg") ||
            itemBrand.includes("sony")
          )
        )
      }

      // Pour Samsung, accepter seulement Samsung
      if (strictBrand === "samsung") {
        return (
          (itemBrand.includes("samsung") ||
            itemModel.includes("samsung") ||
            itemDescription.includes("samsung") ||
            itemType.includes("samsung")) &&
          !(
            itemBrand.includes("apple") ||
            itemBrand.includes("iphone") ||
            itemBrand.includes("huawei") ||
            itemBrand.includes("xiaomi")
          )
        )
      }

      // Pour les autres marques, vÃ©rifier la correspondance exacte
      return (
        itemBrand.includes(brandLower) ||
        itemModel.includes(brandLower) ||
        itemDescription.includes(brandLower) ||
        itemType.includes(brandLower)
      )
    })

    if (!hasStrictBrandMatch) {
      console.log(`âŒ Rejected: Item doesn't match strict brand requirements`)
      return false
    }
  }

  console.log(`âœ… Accepted: Item matches search criteria`)
  return true
}

// Nouvelle fonction pour valider les rÃ©sultats avec l'IA - Version moins stricte pour les animaux
// Nouvelle fonction pour valider les rÃ©sultats avec l'IA - Version moins stricte pour les animaux
async function validateResultWithAI(userInput: string, item: any, language: string): Promise<boolean> {
  if (!process.env.OPENAI_API_KEY) {
    console.log("âš ï¸ OpenAI not configured, skipping AI validation")
    return true // Fallback: accepter le rÃ©sultat
  }

  try {
    // --- MODIFICATION ICI : Ajout de plus de dÃ©tails dans le prompt ---
    const validationPrompts = {
      ar: `Ø£Ù†Øª Ø®Ø¨ÙŠØ± ÙÙŠ Ù…Ø·Ø§Ø¨Ù‚Ø© Ø§Ù„Ø£Ø´ÙŠØ§Ø¡ Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø©. Ù‚Ø§Ø±Ù† Ø¨ÙŠÙ† Ù…Ø§ ÙŠØ¨Ø­Ø« Ø¹Ù†Ù‡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆÙ…Ø§ ÙˆÙØ¬Ø¯ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.

Ø·Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: "${userInput}"

Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯ (Ø§Ù„ØªÙØ§ØµÙŠÙ„ Ø§Ù„ÙƒØ§Ù…Ù„Ø©):
- Ø§Ù„ÙˆØµÙ: ${item.description || "ØºÙŠØ± Ù…ØªÙˆÙØ±"}
- Ø§Ù„ÙØ¦Ø©: ${item.category_name || "ØºÙŠØ± Ù…ØªÙˆÙØ±"}
- Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©: ${item.marque || "ØºÙŠØ± Ù…ØªÙˆÙØ±"}
- Ø§Ù„Ø·Ø±Ø§Ø²: ${item.modele || "ØºÙŠØ± Ù…ØªÙˆÙØ±"}
- Ø§Ù„Ù„ÙˆÙ†: ${item.color || "ØºÙŠØ± Ù…ØªÙˆÙØ±"}
- Ø§Ù„Ø­Ø§Ù„Ø©: ${item.etat || "ØºÙŠØ± Ù…ØªÙˆÙØ±"}
- Ø§Ù„Ù†ÙˆØ¹: ${item.type || "ØºÙŠØ± Ù…ØªÙˆÙØ±"}
- Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©: ${item.city || "ØºÙŠØ± Ù…ØªÙˆÙØ±"}
- ØªØ§Ø±ÙŠØ® Ø§Ù„Ù†Ø´Ø±: ${item.postdate ? new Date(item.postdate).toLocaleString('ar-MA') : "ØºÙŠØ± Ù…ØªÙˆÙØ±"}

Ù„Ù„Ø­ÙŠÙˆØ§Ù†Ø§Øª Ø§Ù„Ø£Ù„ÙŠÙØ©: Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙŠØ¨Ø­Ø« Ø¹Ù† Ø­ÙŠÙˆØ§Ù† (ÙƒÙ„Ø¨ØŒ Ù‚Ø·) ÙˆÙƒØ§Ù† Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯ Ø­ÙŠÙˆØ§Ù† Ù…Ù† Ù†ÙØ³ Ø§Ù„Ù†ÙˆØ¹ØŒ ÙÙ‡Ùˆ Ù…Ø·Ø§Ø¨Ù‚ Ø­ØªÙ‰ Ù„Ùˆ Ø§Ø®ØªÙ„ÙØª Ø§Ù„ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø©.

Ù‡Ù„ Ù‡Ø°Ø§ Ø§Ù„Ø¹Ù†ØµØ± ÙŠØ·Ø§Ø¨Ù‚ Ù…Ø§ ÙŠØ¨Ø­Ø« Ø¹Ù†Ù‡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŸ Ø£Ø¬Ø¨ Ø¨Ù€ "Ù†Ø¹Ù…" Ø£Ùˆ "Ù„Ø§" ÙÙ‚Ø·.`,

      fr: `Tu es un expert en correspondance d'objets perdus. Compare ce que l'utilisateur recherche avec ce qui a Ã©tÃ© trouvÃ© dans la base de donnÃ©es.

Demande de l'utilisateur: "${userInput}"

Objet trouvÃ© (DÃ©tails complets):
- Description: ${item.description || "Non disponible"}
- CatÃ©gorie: ${item.category_name || "Non disponible"}
- Marque: ${item.marque || "Non disponible"}
- ModÃ¨le: ${item.modele || "Non disponible"}
- Couleur: ${item.color || "Non disponible"}
- Ã‰tat: ${item.etat || "Non disponible"}
- Type: ${item.type || "Non disponible"}
- Ville: ${item.city || "Non disponible"}
- Date de publication: ${item.postdate ? new Date(item.postdate).toLocaleString('fr-FR') : "Non disponible"}

Pour les animaux de compagnie: Si l'utilisateur cherche un animal (chien, chat) et que l'objet trouvÃ© est un animal du mÃªme type, c'est une correspondance mÃªme si les dÃ©tails prÃ©cis diffÃ¨rent.

Est-ce que cet objet correspond Ã  ce que l'utilisateur recherche ? RÃ©ponds uniquement par "OUI" ou "NON".`,

      en: `You are an expert in matching lost items. Compare what the user is looking for with what was found in the database.

User request: "${userInput}"

Found item (Full details):
- Description: ${item.description || "Not available"}
- Category: ${item.category_name || "Not available"}
- Brand: ${item.marque || "Not available"}
- Model: ${item.modele || "Not available"}
- Color: ${item.color || "Not available"}
- Condition: ${item.etat || "Not available"}
- Type: ${item.type || "Not available"}
- City: ${item.city || "Not available"}
- Posted on: ${item.postdate ? new Date(item.postdate).toLocaleString('en-US') : "Not available"}

For pets: If the user is looking for an animal (dog, cat) and the found item is an animal of the same type, it's a match even if precise details differ.

Does this item match what the user is looking for? Answer only "YES" or "NO".`,
    }
    // --- FIN DE LA MODIFICATION ---

    const { text } = await generateText({
      model: openai("gpt-4o"),
      messages: [
        {
          role: "system",
          content:
            "Tu es un expert en correspondance d'objets perdus. Pour les animaux de compagnie, sois plus flexible - si l'utilisateur cherche un chien et que l'objet trouvÃ© est un chien, c'est gÃ©nÃ©ralement une correspondance valide. RÃ©ponds uniquement par OUI ou NON.",
        },
        {
          role: "user",
          content: validationPrompts[language] || validationPrompts.fr,
        },
      ],
      maxTokens: 10,
    })

    const response = text.trim().toLowerCase()
    const isValid = response.includes("oui") || response.includes("yes") || response.includes("Ù†Ø¹Ù…")

    console.log(`ğŸ¤– AI Validation for item #${item.id}: ${isValid ? "âœ… VALID" : "âŒ INVALID"} (Response: ${text})`)
    return isValid
  } catch (error) {
    console.error("AI validation error:", error)
    return true // En cas d'erreur, accepter le rÃ©sultat
  }
}

// Fonction d'extraction amÃ©liorÃ©e avec rÃ¨gles strictes
// Fonction d'extraction amÃ©liorÃ©e avec rÃ¨gles strictes
function extractStrictSearchCriteria(text: string) {
  const translatedText = translateToFrench(text)
  const lowerText = translatedText.toLowerCase()
  const originalLower = text.toLowerCase()

  console.log("ğŸ” Extracting search criteria from:", text)

  // Extraction de la ville (OPTIONNELLE maintenant)
  const cities = extractCities(text)
  const city = cities[0] || null

  // Extraction des spÃ©cifications avec modÃ¨les exacts
  const specs = extractPreciseSpecs(text)

  // --- MODIFICATION ICI : Ajout de la gestion des synonymes ---
  let searchSynonyms = []
  for (const category of specs.categories) {
    if (animalSynonyms[category]) {
      searchSynonyms.push(...animalSynonyms[category])
    } else {
      searchSynonyms.push(category) // Garder le terme original pour les autres catÃ©gories
    }
  }
  searchSynonyms = [...new Set(searchSynonyms)] // Supprimer les doublons
  // --- FIN DE LA MODIFICATION ---


  // Extraction du modÃ¨le spÃ©cifique
  let specificModel = null
  const modelPatterns = [
    // Car key patterns
    /clÃ©\s*(de\s*)?(voiture|auto|automobile)\s*([a-z]+)/i,
    /([a-z]+)\s*clÃ©/i,
    // Samsung models
    /samsung\s*(galaxy\s*)?(a\d+|s\d+|note\s*\d+|j\d+|m\d+)/i,
    // iPhone models
    /iphone\s*(\d+(\s*pro)?(\s*max)?|se|xr|xs|x)/i,
    // Huawei models
    /huawei\s*(p\d+|mate\s*\d+|nova\s*\d+|y\d+)/i,
    // Generic model patterns
    /\b([a-z]+\s*\d+[a-z]*)\b/i,
  ]

  for (const pattern of modelPatterns) {
    const match = text.match(pattern)
    if (match) {
      specificModel = match[1] || match[0]
      console.log(`ğŸ“± Found specific model: ${specificModel}`)
      break
    }
  }

  // DÃ©tecter les marques de voiture
  const carBrands = [
    "renault",
    "peugeot",
    "citroÃ«n",
    "citroen",
    "volkswagen",
    "vw",
    "mercedes",
    "bmw",
    "audi",
    "ford",
    "opel",
    "fiat",
    "toyota",
    "nissan",
    "hyundai",
    "kia",
    "seat",
    "skoda",
    "dacia",
  ]

  let detectedCarBrand = null
  for (const brand of carBrands) {
    if (lowerText.includes(brand) || originalLower.includes(brand)) {
      detectedCarBrand = brand
      specs.brands.push(brand)
      specs.categories.push("clÃ©")
      specs.isSpecific = true
      console.log(`ğŸš— Found car brand: ${brand}`)
      break
    }
  }

  return {
    originalText: text,
    city: city,
    brands: specs.brands,
    categories: specs.categories,
    searchSynonyms: searchSynonyms.length > 0 ? searchSynonyms : specs.categories, // Utiliser les synonymes si disponibles
    color: specs.color,
    specificModel: specificModel,
    isSpecific: specs.isSpecific,
    hasStrictCriteria: !!(specs.brands.length > 0 || specs.categories.length > 0), // Ville plus obligatoire
  }
}

// Recherche en base avec rÃ¨gles strictes
// Recherche en base avec rÃ¨gles strictes (VERSION FINALE CORRIGÃ‰E ET ROBUSTE)
async function strictDatabaseSearch(searchCriteria: any) {
  try {
    if (!process.env.DB_HOST) {
      console.log("âš ï¸ Database not configured")
      return { results: [], hasStrictCriteria: false }
    }

    if (!searchCriteria.hasStrictCriteria) {
      console.log("âŒ Strict search requires brand OR category")
      return { results: [], hasStrictCriteria: false }
    }

    let sql = `
      SELECT 
        f.id,
        f.discription as description,
        f.ville as city_id,
        f.cat_ref as category_ref,
        f.marque,
        f.modele,
        f.color,
        f.type,
        f.etat,
        f.postdate,
        c.cname as category_name,
        v.ville as city
      FROM fthings f
      LEFT JOIN catagoery c ON f.cat_ref = c.cid
      LEFT JOIN ville v ON f.ville = v.id
      WHERE 1=1
    `
    const params = []

    // RÃˆGLE 1: Filtre de ville (optionnel)
    if (searchCriteria.city) {
      sql += ` AND LOWER(v.ville) = LOWER(?)`
      params.push(searchCriteria.city)
      console.log(`ğŸ™ï¸ City filter applied: ${searchCriteria.city}`)
    }

    // Construction robuste de la clause de recherche (marques ET/OU catÃ©gories)
    const hasBrands = searchCriteria.brands && searchCriteria.brands.length > 0
    const hasCategories = searchCriteria.searchSynonyms && searchCriteria.searchSynonyms.length > 0
    const searchConditions = []

    if (hasBrands) {
      const brandPattern = searchCriteria.brands.map(b => b.toLowerCase().replace(/[.*+?^${}()|[\]\\]/g, "\\$&")).join('|')
      searchConditions.push(`(
        LOWER(f.marque) REGEXP '\\\\b(${brandPattern})\\\\b' OR
        LOWER(f.discription) REGEXP '\\\\b(${brandPattern})\\\\b' OR
        LOWER(f.type) REGEXP '\\\\b(${brandPattern})\\\\b'
      )`)
    }

    if (hasCategories) {
      const categoryPattern = searchCriteria.searchSynonyms.map(s => s.toLowerCase().replace(/[.*+?^${}()|[\]\\]/g, "\\$&")).join('|')
      searchConditions.push(`(
        LOWER(f.discription) REGEXP '\\\\b(${categoryPattern})\\\\b' OR
        LOWER(c.cname) REGEXP '\\\\b(${categoryPattern})\\\\b' OR
        LOWER(f.type) REGEXP '\\\\b(${categoryPattern})\\\\b'
      )`)
    }
    
    if (searchConditions.length > 0) {
      sql += ` AND (${searchConditions.join(" OR ")})`
    }

    // RÃˆGLE 4: Filtre de modÃ¨le exact
    if (searchCriteria.specificModel) {
      const modelPattern = searchCriteria.specificModel.toLowerCase().replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
      sql += ` AND (LOWER(f.modele) REGEXP '\\\\b${modelPattern}\\\\b' OR LOWER(f.discription) REGEXP '\\\\b${modelPattern}\\\\b')`
    }

    // RÃˆGLE 5: Filtre de couleur exacte
    if (searchCriteria.color) {
      const colorPattern = searchCriteria.color.toLowerCase().replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
      sql += ` AND (LOWER(f.color) REGEXP '\\\\b${colorPattern}\\\\b' OR LOWER(f.discription) REGEXP '\\\\b${colorPattern}\\\\b')`
    }

    // --- CORRECTION MAJEURE : Tri des rÃ©sultats robuste ---
    const orderByClauses = []
    
    if (hasBrands) {
        const brandPattern = searchCriteria.brands[0].toLowerCase().replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        orderByClauses.push(`(CASE WHEN LOWER(f.marque) REGEXP '\\\\b${brandPattern}\\\\b' THEN 1 ELSE 2 END)`);
    }

    if (searchCriteria.specificModel) {
        const modelPattern = searchCriteria.specificModel.toLowerCase().replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        orderByClauses.push(`(CASE WHEN LOWER(f.modele) REGEXP '\\\\b${modelPattern}\\\\b' THEN 1 ELSE 2 END)`);
    }

    // Toujours trier par date en dernier pour la fraÃ®cheur
    orderByClauses.push('f.postdate DESC');

    sql += ` ORDER BY ${orderByClauses.join(', ')} LIMIT 50`;
    // --- FIN DE LA CORRECTION ---

    console.log("ğŸ” Executing final robust database search...")
    console.log("Generated SQL:", sql.replace(/\s+/g, ' ').trim()); // Log pour le dÃ©bogage

    const results = await query(sql, params)
    const resultArray = Array.isArray(results) ? results : []

    console.log(`ğŸ“Š Database search found ${resultArray.length} results`)
    
    return {
      results: resultArray,
      hasStrictCriteria: true,
      searchCriteria: searchCriteria,
    }
  } catch (error) {
    console.error("Database search error:", error)
    return { results: [], hasStrictCriteria: false, error: error }
  }
}

// Fonction principale de validation avec IA
async function validateAndFilterResults(userInput: string, results: any[], language: string) {
  if (results.length === 0) {
    return []
  }

  console.log(`ğŸ¤– Starting AI validation for ${results.length} results...`)

  const validatedResults = []

  // Valider chaque rÃ©sultat avec l'IA
  for (const item of results) {
    const isValid = await validateResultWithAI(userInput, item, language)

    if (isValid) {
      validatedResults.push(item)
      console.log(`âœ… Item #${item.id} validated by AI`)
    } else {
      console.log(`âŒ Item #${item.id} rejected by AI`)
    }

    // Limiter Ã  5 rÃ©sultats validÃ©s maximum
    if (validatedResults.length >= 5) {
      break
    }
  }

  console.log(`ğŸ¯ Final validated results: ${validatedResults.length}/${results.length}`)
  return validatedResults
}

export async function POST(req: Request) {
  try {
    const { messages } = await req.json()
    const lastMessage = messages[messages.length - 1]
    const userInput = lastMessage?.content || ""

    console.log("ğŸ” Processing user input:", userInput)

    // Analyze conversation context
    const context = analyzeConversationContext(messages)
    console.log("ğŸ“‹ Context:", {
      userLanguage: context.userLanguage,
      isNewSearch: context.isNewSearch,
      conversationSpecs: context.conversationSpecs,
      conversationCities: context.conversationCities,
    })

    // Check if user is asking about a specific item ID
    const itemId = isAskingAboutItemId(userInput)
    if (itemId) {
      if (!process.env.DB_HOST) {
        const errorMessages = {
          ar: "âŒ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± Ù…ØªØµÙ„Ø©. Ù„Ø§ ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø¢Ù†.",
          fr: "âŒ Base de donnÃ©es non connectÃ©e. Je ne peux pas rechercher les dÃ©tails des objets pour le moment.",
          en: "âŒ Database not connected. I can't search for item details right now.",
        }
        return NextResponse.json({
          id: Date.now().toString(),
          role: "assistant",
          content: errorMessages[context.userLanguage] || errorMessages.fr,
        })
      }

      try {
        const item = await getItemById(itemId)

        if (item) {
          const responses = {
            ar: `ğŸ¯ **ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù†ØµØ± #${item.id}!**\n\nğŸ“ **Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©:** ${item.city || "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ©"}\nğŸ“ **Ø§Ù„ÙˆØµÙ:** ${item.description || "Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙˆØµÙ"}\n\n**Ø§Ù„ØªÙØ§ØµÙŠÙ„:**\n${item.category_name ? `â€¢ **Ø§Ù„ÙØ¦Ø©:** ${item.category_name}\n` : ""}${item.marque ? `â€¢ **Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©:** ${item.marque}\n` : ""}${item.modele ? `â€¢ **Ø§Ù„Ø·Ø±Ø§Ø²:** ${item.modele}\n` : ""}${item.color ? `â€¢ **Ø§Ù„Ù„ÙˆÙ†:** ${item.color}\n` : ""}${item.type ? `â€¢ **Ø§Ù„Ù†ÙˆØ¹:** ${item.type}\n` : ""}${item.etat ? `â€¢ **Ø§Ù„Ø­Ø§Ù„Ø©:** ${item.etat}\n` : ""}\n${item.postdate ? `ğŸ“… **ØªØ§Ø±ÙŠØ® Ø§Ù„Ù†Ø´Ø±:** ${new Date(item.postdate).toLocaleDateString()}\n` : ""}\nğŸ”— **[Ø§ØªØµÙ„ Ø¨Ø§Ù„ÙˆØ§Ø¬Ø¯](https://mafqoodat.ma/trouve.php?contact=${item.id})**`,
            fr: `ğŸ¯ **Objet #${item.id} trouvÃ© !**\n\nğŸ“ **Ville :** ${item.city || "Inconnue"}\nğŸ“ **Description :** ${item.description || "Aucune description disponible"}\n\n**DÃ©tails :**\n${item.category_name ? `â€¢ **CatÃ©gorie :** ${item.category_name}\n` : ""}${item.marque ? `â€¢ **Marque :** ${item.marque}\n` : ""}${item.modele ? `â€¢ **ModÃ¨le :** ${item.modele}\n` : ""}${item.color ? `â€¢ **Couleur :** ${item.color}\n` : ""}${item.type ? `â€¢ **Type :** ${item.type}\n` : ""}${item.etat ? `â€¢ **Ã‰tat :** ${item.etat}\n` : ""}\n${item.postdate ? `ğŸ“… **PostÃ© le :** ${new Date(item.postdate).toLocaleDateString()}\n` : ""}\nğŸ”— **[Contacter le trouveur](https://mafqoodat.ma/trouve.php?contact=${item.id})**`,
            en: `ğŸ¯ **Item #${item.id} found!**\n\nğŸ“ **City:** ${item.city || "Unknown"}\nğŸ“ **Description:** ${item.description || "No description available"}\n\n**Details:**\n${item.category_name ? `â€¢ **Category:** ${item.category_name}\n` : ""}${item.marque ? `â€¢ **Brand:** ${item.marque}\n` : ""}${item.modele ? `â€¢ **Model:** ${item.modele}\n` : ""}${item.color ? `â€¢ **Color:** ${item.color}\n` : ""}${item.type ? `â€¢ **Type:** ${item.type}\n` : ""}${item.etat ? `â€¢ **Condition:** ${item.etat}\n` : ""}\n${item.postdate ? `ğŸ“… **Posted:** ${new Date(item.postdate).toLocaleDateString()}\n` : ""}\nğŸ”— **[Contact the finder](https://mafqoodat.ma/trouve.php?contact=${item.id})**`,
          }

          return NextResponse.json({
            id: Date.now().toString(),
            role: "assistant",
            content: responses[context.userLanguage] || responses.fr,
          })
        } else {
          const notFoundMessages = {
            ar: `âŒ **Ø§Ù„Ø¹Ù†ØµØ± #${itemId} ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯**\n\nÙ„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¹Ù†ØµØ± Ø¨Ø§Ù„Ø±Ù‚Ù… #${itemId} ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.`,
            fr: `âŒ **Objet #${itemId} non trouvÃ©**\n\nJe n'ai pas pu trouver un objet avec l'ID #${itemId} dans notre base de donnÃ©es.`,
            en: `âŒ **Item #${itemId} not found**\n\nI couldn't find an item with ID #${itemId} in our database.`,
          }
          return NextResponse.json({
            id: Date.now().toString(),
            role: "assistant",
            content: notFoundMessages[context.userLanguage] || notFoundMessages.fr,
          })
        }
      } catch (error) {
        const errorMessages = {
          ar: `âŒ **Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¹Ù†ØµØ± #${itemId}**\n\nØ­Ø¯Ø«Øª Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.`,
          fr: `âŒ **Erreur lors de la recherche de l'objet #${itemId}**\n\nIl y a eu un problÃ¨me d'accÃ¨s Ã  la base de donnÃ©es.`,
          en: `âŒ **Error looking up Item #${itemId}**\n\nThere was a problem accessing the database.`,
        }
        return NextResponse.json({
          id: Date.now().toString(),
          role: "assistant",
          content: errorMessages[context.userLanguage] || errorMessages.fr,
        })
      }
    }

    // Check if user is searching for lost items
    
  const isSearchQuery = isSearchingForItems(userInput, context)
    console.log("ğŸ” Is search query:", isSearchQuery)

    // Dans la fonction POST, remplacer la section de recherche par :

    if (isSearchQuery) {
      // Extraction des critÃ¨res de recherche stricts
      const searchCriteria = extractStrictSearchCriteria(userInput)
      console.log("ğŸ” Strict search criteria:", searchCriteria)

      // Ã‰tape 1: Recherche stricte en base de donnÃ©es
      const searchResult = await strictDatabaseSearch(searchCriteria)

      // VÃ©rifier si les critÃ¨res stricts sont remplis
      if (!searchResult.hasStrictCriteria) {
        const response = generateResponse("missingDetails", {}, context.userLanguage)
        return NextResponse.json({
          id: Date.now().toString(),
          role: "assistant",
          content: response,
        })
      }

      // Ã‰tape 2: Validation des rÃ©sultats avec l'IA
      const validatedResults = await validateAndFilterResults(userInput, searchResult.results, context.userLanguage)

      // Ã‰tape 3: GÃ©nÃ©rer la rÃ©ponse finale
      if (validatedResults.length > 0) {
        // GÃ©nÃ©rer une rÃ©ponse personnalisÃ©e avec l'IA
        let aiResponse = ""

        if (process.env.OPENAI_API_KEY) {
          try {
            const responsePrompts = {
              ar: `Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙŠØ¨Ø­Ø« Ø¹Ù†: "${userInput}"

ÙˆØ¬Ø¯Øª ${validatedResults.length} Ø¹Ù†Ø§ØµØ± Ù…Ø·Ø§Ø¨Ù‚Ø©. Ø§ÙƒØªØ¨ Ø±Ø¯ Ù…Ù‡Ø°Ø¨ ÙˆÙˆØ¯ÙˆØ¯ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© ÙŠØ®Ø¨Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ù†Ùƒ ÙˆØ¬Ø¯Øª Ù†ØªØ§Ø¦Ø¬ Ù…Ø·Ø§Ø¨Ù‚Ø© ÙˆØ£Ù†Ù‡ ÙŠÙ…ÙƒÙ†Ù‡ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª Ø£Ø¯Ù†Ø§Ù‡ Ù„Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø£Ø´Ø®Ø§Øµ Ø§Ù„Ø°ÙŠÙ† ÙˆØ¬Ø¯ÙˆØ§ Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù†Ø§ØµØ±.`,

              fr: `L'utilisateur recherche: "${userInput}"

J'ai trouvÃ© ${validatedResults.length} objets correspondants. Ã‰cris une rÃ©ponse polie et amicale en franÃ§ais qui informe l'utilisateur que tu as trouvÃ© des rÃ©sultats correspondants et qu'il peut consulter les cartes ci-dessous pour contacter les personnes qui ont trouvÃ© ces objets.`,

              en: `The user is looking for: "${userInput}"

I found ${validatedResults.length} matching items. Write a polite and friendly response in English that informs the user that you found matching results and they can check the cards below to contact the people who found these items.`,
            }

            const { text } = await generateText({
              model: openai("gpt-4o"),
              messages: [
                {
                  role: "system",
                  content:
                    "Tu es un assistant serviable pour une plateforme d'objets perdus. Sois poli, empathique et encourageant.",
                },
                {
                  role: "user",
                  content: responsePrompts[context.userLanguage] || responsePrompts.fr,
                },
              ],
              maxTokens: 200,
            })

            aiResponse = text
          } catch (error) {
            console.error("AI response generation error:", error)
            // Fallback response
            const fallbackResponses = {
              ar: `ğŸ¯ **ÙˆØ¬Ø¯Øª ${validatedResults.length} Ø¹Ù†Ø§ØµØ± Ù…Ø·Ø§Ø¨Ù‚Ø© Ù„Ø¨Ø­Ø«Ùƒ!**\n\nØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª Ø£Ø¯Ù†Ø§Ù‡ ÙˆØ§ØªØµÙ„ Ø¨Ø§Ù„Ø£Ø´Ø®Ø§Øµ Ø§Ù„Ø°ÙŠÙ† ÙˆØ¬Ø¯ÙˆØ§ Ø§Ù„Ø¹Ù†Ø§ØµØ±.`,
              fr: `ğŸ¯ **J'ai trouvÃ© ${validatedResults.length} objets correspondant Ã  votre recherche !**\n\nConsultez les cartes ci-dessous et contactez les personnes qui ont trouvÃ© les objets.`,
              en: `ğŸ¯ **I found ${validatedResults.length} items matching your search!**\n\nCheck the cards below and contact the people who found the items.`,
            }
            aiResponse = fallbackResponses[context.userLanguage] || fallbackResponses.fr
          }
        }

        const missingPersons = validatedResults.map((item) => ({
          id: item.id.toString(),
          description: item.description || "Aucune description disponible",
          city: item.city || "Inconnue",
          category_name: item.category_name,
          marque: item.marque,
          modele: item.modele,
          color: item.color,
          type: item.type,
          etat: item.etat,
          postdate: item.postdate,
          contactUrl: `https://mafqoodat.ma/trouve.php?contact=${item.id}`,
        }))

        return NextResponse.json({
          id: Date.now().toString(),
          role: "assistant",
          content: aiResponse,
          missingPersons: missingPersons,
        })
      } else {
        // Aucun rÃ©sultat validÃ© - suggÃ©rer de crÃ©er une annonce
        const noResultsResponses = {
          ar: `âŒ **Ù„Ù… Ø£Ø¬Ø¯ Ø£ÙŠ Ø¹Ù†Ø§ØµØ± ØªØ·Ø§Ø¨Ù‚ Ø¨Ø­Ø«Ùƒ Ø¨Ø¯Ù‚Ø©**\n\nØ¨Ø­Ø«Øª Ø¹Ù†: "${userInput}"\n\nğŸ†• **Ø£Ù†Ø´Ø¦ Ø¥Ø¹Ù„Ø§Ù† Ø¬Ø¯ÙŠØ¯:**\n[CRÃ‰ER_ANNONCE]\n\nğŸ’¡ **Ù†ØµÙŠØ­Ø©:** ØªØ£ÙƒØ¯ Ù…Ù† ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© ÙˆØ§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø¨ÙˆØ¶ÙˆØ­`,
          fr: `âŒ **Je n'ai trouvÃ© aucun objet correspondant exactement Ã  votre recherche**\n\nVous cherchiez: "${userInput}"\n\nğŸ†• **CrÃ©ez une nouvelle annonce:**\n[CRÃ‰ER_ANNONCE]\n\nğŸ’¡ **Conseil:** Assurez-vous d'Ã©crire clairement la marque et la ville`,
          en: `âŒ **I found no items matching your search exactly**\n\nYou were looking for: "${userInput}"\n\nğŸ†• **Create a new post:**\n[CRÃ‰ER_ANNONCE]\n\nğŸ’¡ **Tip:** Make sure to clearly write the brand and city`,
        }

        return NextResponse.json({
          id: Date.now().toString(),
          role: "assistant",
          content: noResultsResponses[context.userLanguage] || noResultsResponses.fr,
        })
      }
    } else {
      // Use ChatGPT API for general conversation with fallback
      console.log("ğŸ’¬ Using general conversation mode")

      // Fallback response if OpenAI is not available
      const fallbackResponses = {
        ar: 'Ø£Ù†Ø§ Ù‡Ù†Ø§ Ù„Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ ÙÙŠ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø´ÙŠØ§Ø¡ Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø© ÙÙŠ Ø§Ù„Ù…ØºØ±Ø¨. Ø¥Ø°Ø§ ÙÙ‚Ø¯Øª Ø´ÙŠØ¦Ù‹Ø§ØŒ Ø£Ø®Ø¨Ø±Ù†ÙŠ Ø¨Ù†ÙˆØ¹ Ø§Ù„Ø´ÙŠØ¡ ÙˆØ§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© ÙˆØ³Ø£Ø¨Ø­Ø« Ù„Ùƒ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª!\n\n**Ù…Ø«Ø§Ù„:** "ÙÙ‚Ø¯Øª Ø¢ÙŠÙÙˆÙ† Ø£Ø³ÙˆØ¯" Ø£Ùˆ "Ø£Ø¨Ø­Ø« Ø¹Ù† Ø³Ø§Ù…Ø³ÙˆÙ†Øº"',
        fr: 'Je suis lÃ  pour vous aider Ã  retrouver vos objets perdus au Maroc. Si vous avez perdu quelque chose, dites-moi quel objet et la marque spÃ©cifique et je rechercherai dans notre base de donnÃ©es !\n\n**Exemple :** "J\'ai perdu mon iPhone noir" ou "Je cherche un Samsung"',
        en: 'I\'m here to help you find your lost items in Morocco. If you\'ve lost something, tell me what item and the specific brand and I\'ll search our database for you!\n\n**Example:** "I lost my black iPhone" or "Looking for Samsung"',
      }

      if (!process.env.OPENAI_API_KEY) {
        return NextResponse.json({
          id: Date.now().toString(),
          role: "assistant",
          content: fallbackResponses[context.userLanguage] || fallbackResponses.fr,
        })
      }

      try {
        const systemPrompts = {
          ar: "Ø£Ù†Øª Ù…Ø³Ø§Ø¹Ø¯ Ù„Ù…Ù†ØµØ© Ù…ØºØ±Ø¨ÙŠØ© Ù„Ù„Ø£Ø´ÙŠØ§Ø¡ Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø© ÙˆØ§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© ØªØ³Ù…Ù‰ Ù…ÙÙ‚ÙˆØ¯Ø§Øª. ØªØ³Ø§Ø¹Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙÙŠ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø´ÙŠØ§Ø¡ Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø© Ø¨Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©. Ø¹Ù†Ø¯Ù…Ø§ ÙŠØ°ÙƒØ± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¹Ù„Ø§Ù…Ø© ØªØ¬Ø§Ø±ÙŠØ© Ù…Ø­Ø¯Ø¯Ø© (Ù…Ø«Ù„ Ø¢ÙŠÙÙˆÙ†ØŒ Ø³Ø§Ù…Ø³ÙˆÙ†Øº)ØŒ Ø§Ø¨Ø­Ø« Ø¹Ù† ØªÙ„Ùƒ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø¨Ø§Ù„Ø¶Ø¨Ø·. Ø±Ø¯ Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©. ÙƒÙ† Ù…ÙÙŠØ¯Ø§Ù‹ ÙˆÙ…ØªØ¹Ø§Ø·ÙØ§Ù‹.",
          fr: "Tu es un assistant pour une plateforme marocaine d'objets perdus et trouvÃ©s appelÃ©e Mafqoodat. Tu aides les utilisateurs avec les objets perdus et trouvÃ©s avec une haute prÃ©cision. Quand l'utilisateur mentionne une marque spÃ©cifique (comme iPhone, Samsung), recherche exactement cette marque. RÃ©ponds toujours en franÃ§ais. Sois utile et empathique.",
          en: "You are an assistant for a Moroccan lost and found platform called Mafqoodat. You help users with lost and found items with high precision. When the user mentions a specific brand (like iPhone, Samsung), search for exactly that brand. Always respond in English. Be helpful and empathetic.",
        }

        const { text } = await generateText({
          model: openai("gpt-4o"),
          messages: [
            {
              role: "system",
              content: systemPrompts[context.userLanguage] || systemPrompts.fr,
            },
            ...messages.map((msg) => ({
              role: msg.role,
              content: msg.content,
            })),
          ],
        })

        return NextResponse.json({
          id: Date.now().toString(),
          role: "assistant",
          content: text,
        })
      } catch (error) {
        console.error("OpenAI API error:", error)
        return NextResponse.json({
          id: Date.now().toString(),
          role: "assistant",
          content: fallbackResponses[context.userLanguage] || fallbackResponses.fr,
        })
      }
    }
  } catch (error) {
    console.error("Chat API error:", error)
    return NextResponse.json({
      id: Date.now().toString(),
      role: "assistant",
      content: "Une erreur s'est produite. Veuillez rÃ©essayer ou actualiser la page.",
    })
  }
}
