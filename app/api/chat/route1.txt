import { streamText, type CoreMessage } from "ai"
import { openai } from "@ai-sdk/openai"
import { z } from "zod"
import { query } from "@/lib/db"
import { NextResponse } from "next/server"

export const maxDuration = 30

// ğŸ” Fonction de recherche directe
async function searchDatabase(args: { 
  item: string
  brand?: string
  color?: string
  city?: string
}) {
  console.log("Server: ğŸ”µ searchDatabase START", args)
  try {
    // Construction des mots-clÃ©s (l'IA est maintenant chargÃ©e de les fournir en franÃ§ais)
    let allKeywords: string[] = []
    if (args.item) allKeywords.push(...args.item.toLowerCase().split(" "))
    if (args.brand) allKeywords.push(args.brand.toLowerCase())
    if (args.color) allKeywords.push(args.color.toLowerCase())
    allKeywords = [...new Set(allKeywords.filter((w) => w.length > 2))]
    console.log(`Server: ğŸ§  Combined search keywords (French): [${allKeywords.join(", ")}]`)

    const whereConditions: string[] = []
    const params: string[] = []

    allKeywords.forEach((keyword) => {
      whereConditions.push(`LOWER(f.discription) LIKE ?`)
      params.push(`%${keyword}%`)
    })

    if (args.city) {
      whereConditions.push(`LOWER(v.ville) LIKE ?`)
      params.push(`%${args.city.toLowerCase()}%`)
    }

    if (whereConditions.length === 0) {
      console.log("Server: âš ï¸ No search conditions, returning empty results.")
      return []
    }

    const sql = `
          SELECT 
            f.id, f.discription as description, v.ville as city, c.cname as category_name,
            f.marque, f.modele, f.color, f.type, f.etat, f.postdate
          FROM fthings f
          LEFT JOIN catagoery c ON f.cat_ref = c.cid
          LEFT JOIN ville v ON f.ville = v.id
          WHERE ${whereConditions.join(" AND ")}
            ORDER BY f.postdate DESC LIMIT 5;
        `

    console.log("Server: ğŸ” Executing SQL:", sql.trim().replace(/\s+/g, " "))
    console.log("Server: ğŸ“¦ With params:", params)

    const results = await query(sql, params)
    console.log("Server: ğŸŸ¢ searchDatabase END - Rows found:", Array.isArray(results) ? results.length : 0)

    return Array.isArray(results)
      ? results.map((item) => ({
          ...item,
          id: String(item.id),
          contactUrl: `https://mafqoodat.ma/trouve.php?contact=${item.id}`,
        }))
      : []
    } catch (error) {
    console.error("Server: âŒ Database search error:", error)
    return []
    }
}

// âœ… Le point d'entrÃ©e principal
export async function POST(req: Request) {
  console.log("Server: --- New POST /api/chat request received ---")
  const { messages }: { messages: CoreMessage[] } = await req.json()
  const filteredMessages = messages.filter((m) => m.role !== "tool")
  const lastMessageContent = filteredMessages[filteredMessages.length - 1]?.content || ""

  // Detect language based on the last message
  let lang = "fr" // Default to French
  if (/[a-zA-Z]/.test(lastMessageContent) && !/[\u0600-\u06FF]/.test(lastMessageContent)) {
    lang = "en" // Contains Latin characters but no Arabic, assume English
  } else if (/[\u0600-\u06FF]/.test(lastMessageContent)) {
    lang = "ar" // Contains Arabic characters
  }
  console.log(`Server: Detected language: ${lang}`)

  // Improved System Prompt for all languages
  const systemPrompt = `You are an expert assistant for the "Mafqoodat" platform, specializing in lost and found items in Morocco.

**CRITICAL: ALL YOUR RESPONSES MUST BE ENTIRELY IN THE LANGUAGE OF THE USER'S LAST MESSAGE (Arabic, French, or English).**

**IMPORTANT: You MUST ALWAYS provide a text response after using any tool, even if the user's follow-up message is just punctuation like "!" or "." or seems unrelated.**

Here's how you should operate:

ğŸŸ¢ **1. General Conversation:** If the user's message is a general greeting, thank you, a question about your capabilities, or unrelated to lost items, respond naturally and politely in their detected language, **without using any tool**.

ğŸ” **2. Search Intent:** If the user's message mentions an object (even a single word like "phone", "wallet", "dog", "Ù‡Ø§ØªÙ", "Ù…Ø­ÙØ¸Ø©", "ÙƒÙ„Ø¨", "tÃ©lÃ©phone", "sac", "chien"), this is a search query:
  - **Immediately use the 'searchDatabase' tool.**
  - **Extract ALL relevant information** (item, city, brand, color) from the user's message and translate these parameters to French before sending them to the tool.
  - **ALWAYS provide a comprehensive text response after the tool execution, regardless of what the user says next.**

ğŸ“„ **3. Processing Search Results (MANDATORY after tool execution):**
  - **ALWAYS analyze and present the results, even if the user's follow-up message is unclear or just punctuation.**
  - **If items are found:**
      - Start with: "I found items that might match. Please review them:" (or equivalent in the detected language).
      - Present each item in Markdown format with these fields, translating all details to the user's language:
        * **Description:** [translated description]
        * **City:** [translated city]  
        * **Category:** [translated category]
        * **Brand:** [translated brand or "Unknown"]
        * **Model:** [translated model or "Unbranded"] 
        * **Color:** [translated color or "Not specified"]
        * **Post Date:** [formatted date]
        * **Contact Link:** [contactUrl with "Contact" as link text]

  - **If no items are found:**
      - Clearly state: "No matching items were found" (in the detected language).
      - Always suggest: "You can create a new ad for your lost item: [Create a new ad](action:create_ad)"

â“ **4. Unclear Search Intent:** If the user seems to be searching but doesn't mention a specific item, ask: "What kind of item did you lose?" (in the detected language).

ğŸš« **5. Non-search Messages:** For empty, meaningless, or completely unrelated messages, respond as a helpful assistant without using tools.

**REMEMBER: After ANY tool execution, you MUST provide a substantive response about the search results, regardless of what the user says next.**`

  // Prepare messages for the AI model
  let messagesForAI: CoreMessage[] = [...filteredMessages]

  // If this is the very first user message, prepend a greeting
  if (filteredMessages.length === 1 && filteredMessages[0].role === "user") {
    const greeting = {
      fr: "Bonjour ! Comment puis-je vous aider Ã  retrouver votre objet perdu ?",
      ar: "Ù…Ø±Ø­Ø¨Ø§Ù‹! ÙƒÙŠÙ ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ ÙÙŠ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ØºØ±Ø¶Ùƒ Ø§Ù„Ù…ÙÙ‚ÙˆØ¯ØŸ",
      en: "Hello! How can I assist you in finding your lost item?",
    }
    messagesForAI = [{ role: "assistant", content: greeting[lang] }, ...filteredMessages]
    console.log("Server: Prepended initial greeting.")
  }

  console.log("Server: Messages sent to AI:", JSON.stringify(messagesForAI, null, 2))

  try {
    console.log("Server: ğŸŸ¤ streamText START - Calling AI model...")
    const result = await streamText({
      model: openai("gpt-4o"),
      system: systemPrompt,
      messages: messagesForAI,
      tools: {
        searchDatabase: {
          description: "Search for lost items in the database. Use immediately when user expresses search intent.",
          parameters: z.object({
            item: z.string().describe("The item to search for, translated to French."),
            city: z.string().optional().describe("The city to search in, translated to French."),
            brand: z.string().optional().describe("The brand of the item, translated to French."),
            color: z.string().optional().describe("The color of the item, translated to French."),
          }),
          execute: async (args) => {
            console.log("Server: ğŸŸ£ Tool execute START - Calling searchDatabase...")
            const toolResult = await searchDatabase(args)
            console.log(
              "Server: ğŸŸ  Tool execute END - Result from searchDatabase:",
              JSON.stringify(toolResult).substring(0, 200) + "...",
            )
            return toolResult
          },
        },
      },
      // Add these parameters to ensure more reliable responses
      maxTokens: 1000,
      temperature: 0.3,
    })
    
    console.log("Server: âš« streamText END - Result object obtained from AI model.")
    const response = result.toDataStreamResponse()
    console.log("Server: ğŸ”µ After toDataStreamResponse() - Stream initiated for client. Returning response.")
    return response
  } catch (error) {
    console.error("Server: âŒ streamText error caught:", error)
    return NextResponse.json({ error: "Failed to generate AI response" }, { status: 500 })
  } finally {
    console.log("Server: --- POST /api/chat request processing finished ---")
  }
}