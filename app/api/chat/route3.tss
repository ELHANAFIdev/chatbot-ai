import { streamText, type CoreMessage } from "ai"
import { openai } from "@ai-sdk/openai"
import { z } from "zod"
import { query } from "@/lib/db"
import { NextResponse } from "next/server"

export const maxDuration = 30

// üîé Fonction de recherche directe (No changes needed)
async function searchDatabase(args: {
  item: string
  brand?: string
  color?: string
  city?: string
}) {
  console.log("Server: üöÄ searchDatabase START", args)
  try {
    let allKeywords: string[] = []
    if (args.item) allKeywords.push(...args.item.toLowerCase().split(" "))
    if (args.brand) allKeywords.push(args.brand.toLowerCase())
    if (args.color) allKeywords.push(args.color.toLowerCase())
    allKeywords = [...new Set(allKeywords.filter((w) => w.length > 2))]
    console.log(`Server: üßê Combined search keywords (French): [${allKeywords.join(", ")}]`)

    const whereConditions: string[] = []
    const params: string[] = []

    allKeywords.forEach((keyword) => {
      whereConditions.push(`LOWER(f.discription) LIKE ?`)
      params.push(`%${keyword}%`)
    })

    if (args.city) {
      whereConditions.push(`LOWER(v.ville) LIKE ?`)
      params.push(`%${args.city.toLowerCase()}%`)
    }

    if (whereConditions.length === 0) {
      console.log("Server: ‚ö†Ô∏è No search conditions, returning empty results.")
      return []
    }

    const sql = `
      SELECT
        f.id, f.discription as description, v.ville as city, c.cname as category_name,
        f.marque, f.modele, f.color, f.type, f.etat, f.postdate
      FROM fthings f
             LEFT JOIN catagoery c ON f.cat_ref = c.cid
             LEFT JOIN ville v ON f.ville = v.id
      WHERE ${whereConditions.join(" AND ")}
      ORDER BY f.postdate DESC LIMIT 5;
    `

    console.log("Server: Executing SQL:", sql.trim().replace(/\s+/g, " "))
    console.log("Server: With params:", params)

    const results = await query(sql, params) as any[]
    console.log("Server: ‚úÖ searchDatabase END - Rows found:", Array.isArray(results) ? results.length : 0)

    return Array.isArray(results)
        ? results.map((item: any) => ({
          ...item,
          id: String(item.id),
          contactUrl: `https://mafqoodat.ma/trouve.php?contact=${item.id}`,
        }))
        : []
  } catch (error) {
    console.error("Server: ‚ùå Database search error:", error)
    return []
  }
}

// ‚úÖ Le point d'entr√©e principal
export async function POST(req: Request) {
  console.log("Server: --- New POST /api/chat request received ---")
  const { messages }: { messages: CoreMessage[] } = await req.json()
  const filteredMessages = messages.filter((m) => m.role !== "tool")
  const lastMessage = filteredMessages[filteredMessages.length - 1]
  const lastMessageContent = lastMessage
      ? (typeof lastMessage.content === 'string'
              ? lastMessage.content
              : lastMessage.content.map(part =>
                  'text' in part ? part.text : ''
              ).join(' ')
      )
      : ""

  let lang: 'fr' | 'en' | 'ar' = "fr"
  if (/[a-zA-Z]/.test(lastMessageContent) && !/[\u0600-\u06FF]/.test(lastMessageContent)) {
    lang = "en"
  } else if (/[\u0600-\u06FF]/.test(lastMessageContent)) {
    lang = "ar"
  }
  console.log(`Server: Detected language: ${lang}`)
  
  const isFirstMessage = filteredMessages.length === 1 && filteredMessages[0].role === "user"

  // CORRECTED: Escaped the inner backticks with a backslash `\`
const systemPrompt = `You are a smart and friendly assistant working for "Mafqoodat", a lost and found platform in Morocco.

üåç **Languages**:
- You speak **Moroccan Darija**, **French**, and **English**.
You MUST respond only in this language: **${lang}**
  - If user writes in Darija: respond in Darija.
  - If French: respond in French.
  - If Arabic (MSA): respond in Arabic.
  - If English: respond in English.

üé≠ **Tone**:
- Be warm, helpful, and human.
- If the user asks something unrelated like "Do you know Ronaldo?", use humor and redirect:
 

üîÅ **Main Workflow**:

1. ‚úÖ **Detect User Intent**:
   - If the message contains a lost item ("sac", "bag", "ÿ≠ŸÇŸäÿ®ÿ©", "t√©l√©phone", "ŸÖŸÅÿ™ÿßÿ≠", etc.), treat it as a **search request**.
   - If the message is unclear (e.g., "ÿ∂ÿßÿπÿ™ ŸÑŸä ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©" without details), ask for **more info** (city, color, brand...).
   - If it's a greeting or casual message, **reply politely** without using any tools.

2. üîç **Use the \`searchDatabase\` tool**:
   - Only use it after collecting **enough details** (at least item + 1 other detail).
   - Always **translate item, city, brand, and color to French** before calling the tool.

3. üìã **Present the Results**:
   - After the tool runs, **always respond with a human explanation**.
   - If items are found:
     - Start with something like: "ŸÑŸÇŸäÿ™ ÿ¥Ÿä ÿ≠ŸàÿßŸäÿ¨ ŸÖŸÖŸÉŸÜ ŸäŸÉŸàŸÜŸàÿß ÿØŸäÿßŸÑŸÉ:"
     - Format each item in Markdown:
       - **Description:** [translated]
       - **City:** [translated]
       - **Category:** [translated]
       - **Brand:** [translated]
       - **Color:** [translated]
       - **Post Date:** [formatted]
       - **Contact Link:** [Contact](contact_url)
   - If no items are found:
     - Say: "ŸÖÿß ŸÑŸÇŸäÿ™ÿ¥ ÿ¥Ÿä ÿ≠ÿßÿ¨ÿ© ŸÉÿ™ÿ¥ÿ®Ÿá ŸÑŸáÿßÿØ ÿßŸÑŸàÿµŸÅ..."
     - Suggest: "ÿ™ŸÇÿØÿ± ÿ™ÿ≤ŸäÿØ ÿ•ÿπŸÑÿßŸÜ ÿ¨ÿØŸäÿØ ŸáŸÜÿß: [Create a new ad](action:create_ad)"

üöÄ ${isFirstMessage ? `**First Message Detected**:
- Begin with a short friendly greeting in the user's language.
- Then proceed to intent detection and the workflow above.` : ''}
`;


  const messagesForAI: CoreMessage[] = filteredMessages

  console.log("Server: Messages sent to AI:", JSON.stringify(messagesForAI, null, 2))

  try {
    console.log("Server: üß† streamText START - Calling AI model...")
    const result = streamText({
      model: openai("gpt-4o"),
      system: systemPrompt,
      messages: messagesForAI,
      tools: {
        searchDatabase: {
          description: "Searches the database for lost items. Use this only after getting enough details from the user. Always translate search parameters to French.",
          parameters: z.object({
            item: z.string().describe("The item to search for, translated to French."),
            city: z.string().optional().describe("The city to search in, translated to French."),
            brand: z.string().optional().describe("The brand of the item, translated to French."),
            color: z.string().optional().describe("The color of the item, translated to French."),
          }),
          execute: async (args) => {
            console.log("Server: üõ†Ô∏è Tool execute START - Calling searchDatabase...")
            const toolResult = await searchDatabase(args)
            console.log(
                "Server: üì¶ Tool execute END - Result from searchDatabase:",
                JSON.stringify(toolResult).substring(0, 200) + "..."
            )
            return toolResult
          },
        },
      },
      maxTokens: 1000,
      temperature: 0.1,
      toolChoice: "auto",
      maxSteps: 5,
      onStepFinish: (step) => {
        console.log("Server: Step finished:", step.stepType)
        if (step.stepType === 'tool-result') {
          console.log("Server: Tool call completed, expecting text response next")
        }
      },
      experimental_continueSteps: true,
    })

    console.log("Server: ‚ú® streamText END - Result object obtained from AI model.")
    const response = result.toDataStreamResponse()
    console.log("Server: ‚û°Ô∏è After toDataStreamResponse() - Stream initiated for client. Returning response.")
    return response
  } catch (error) {
    console.error("Server: ‚ùå streamText error caught:", error)
    return NextResponse.json({ error: "Failed to generate AI response" }, { status: 500 })
  } finally {
    console.log("Server: --- POST /api/chat request processing finished ---")
  }
}